# backend/utils/ai_core/database.py

"""
This module contains the MongoCollectionAdapter, which makes a MongoDB collection
behave like a ChromaDB collection for the AI's query system.
"""

import re
from typing import Dict, List
from pymongo.collection import Collection

class MongoCollectionAdapter:
    """
    Acts as an adapter to make a MongoDB collection behave like a ChromaDB collection for structured filtering.
    This class is the core of the safe migration, ensuring no logic in the AIAnalyst class needs to change.
    It receives the complex, Chroma-style `where` clause from the AI's `search_database` method
    and translates it into a native MongoDB query.
    """
    def __init__(self, collection):
        """
        Initializes the adapter with a pymongo collection object.
        Args:
            collection: An active pymongo.collection.Collection instance.
        """
        self.collection = collection

    def _format_output(self, documents: List[Dict]) -> Dict:
        """
        [MODIFIED & MORE ROBUST] Now dynamically constructs the 'content' string if it's
        missing from the database document, ensuring uniqueness for de-duplication.
        Also adds an 'image_url' to the metadata if an image is available.
        """
        if not documents:
            return {"documents": [[]], "metadatas": [[]], "ids": [[]]}

        docs_list = []
        metas_list = []
        ids_list = [str(doc.get("_id", "")) for doc in documents]
        
        base_url = "http://127.0.0.1:8000" # Your FastAPI server URL


        # In database.py, inside MongoCollectionAdapter._format_output

# --- REPLACE THE "THIS IS THE FIX" BLOCK WITH THIS ---

        for doc in documents:
            content_string = doc.get("content")
            
            if not content_string:
                # Check the document's type to generate appropriate content
                data_type = doc.get("data_type")
                name = doc.get("full_name", "N/A")
                stud_id = doc.get("student_id", "N/A")
                course = doc.get("course", "N/A")
                year = doc.get("year", "N/A")

                if data_type == "student_grades":
                    # Create a unique content string for grade documents
                    gwa = doc.get("gwa", "N/A")
                    content_string = (
                        f"Grade summary for {name} ({stud_id}). "
                        f"Program: {course}, Year: {year}. GWA: {gwa}."
                    )
                else:
                    # Fallback to the original student profile content string
                    section = doc.get("section", "N/A")
                    department = doc.get("department", "N/A")
                    content_string = (
                        f"Student profile for {name}. ID: {stud_id}. "
                        f"Program: {course}, Year: {year}, Section: {section}. "
                        f"Department: {department}."
                    )
            
            docs_list.append(content_string)
            # --- END OF FIX ---

            metadata = {k: (str(v) if k != "_id" else str(v))
            for k, v in doc.items()
            if k not in ("image", "audio")}
            metas_list.append(metadata)

        return {"documents": [docs_list], "metadatas": [metas_list], "ids": [ids_list]}
    

    def peek(self, limit: int = 10) -> Dict:
        """Mimics ChromaDB's .peek() method by calling .get()."""
        return self.get(limit=limit)

    def _translate_where_clause(self, clause: dict) -> dict:
        """
        Recursively translates the AI's complex, Chroma-style `where_clause` into a
        MongoDB query filter. This is the "brain" of the adapter. It handles logical
        operators ($or, $and) and translates AI-friendly field names (e.g., "program", "year_level")
        to the actual field names in your database (e.g., "course", "year").

        Args:
            clause: The `where` clause dictionary generated by the AIAnalyst.

        Returns:
            A dictionary formatted as a valid MongoDB query filter.
        """
        if not isinstance(clause, dict):
            return clause

        mongo_clause = {}
        for key, value in clause.items():
            # Recursively handle logical operators
            if key in ["$or", "$and"]:
                mongo_clause[key] = [self._translate_where_clause(item) for item in value]
                continue
            
            # Translate field names from AI context to DB context
            db_key = key
            if key in ["program", "course"]:
                db_key = "course"
            elif key in ["year_level", "year", "yr"]:
                db_key = "year"
            # Add other translations here if needed, e.g., "full_name" -> "name"
            
            # Recursively translate nested values (e.g., inside an '$in' operator)
            mongo_clause[db_key] = self._translate_where_clause(value)

        return mongo_clause

    def count(self) -> int:
        """Mimics ChromaDB's .count() method."""
        return self.collection.count_documents({})

    def get(self, where: Dict = None, limit: int = 100, **kwargs) -> Dict:
        """Mimics ChromaDB's .get() method."""
        filter_query = self._translate_where_clause(where) if where else {}
        results = list(self.collection.find(filter_query).limit(limit))
        return self._format_output(results)

    def query(self, query_texts: List[str], n_results: int = 10, where: Dict = None, where_document: Dict = None) -> Dict:
        """
        [MODIFIED] A more robust version that handles multi-word name searches
        by splitting the query and searching for all words individually.
        """
        filter_query = self._translate_where_clause(where) if where else {}
        search_text = None

        if where_document and "$contains" in where_document:
            search_text = where_document["$contains"]
        elif query_texts and query_texts != ["*"]:
            search_text = query_texts[0]

        if search_text:
            # --- THIS IS THE FIX ---
            # Split the search query into individual words
            words = search_text.split()
            
            if words:
                # Build a regex that requires all words to be present, in any order.
                # This uses positive lookaheads: `(?=.*word1)(?=.*word2)`
                regex_pattern = "".join([f"(?=.*{re.escape(word)})" for word in words])
                
                # Apply this flexible regex to the 'full_name' field.
                filter_query.setdefault("full_name", {"$regex": regex_pattern, "$options": "i"})
            # --- END OF FIX ---

        results = list(self.collection.find(filter_query).limit(n_results))
        return self._format_output(results)
